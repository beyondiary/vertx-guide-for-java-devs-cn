= 介绍

本指南简要的介绍了 Vertx 的异步编程，主要针对使用主流非异步 Web 开发框架和库(例如 Java EE , Spring)的开发人员。

== 关于本指南

我们假定读者熟悉 Java 编程语言以及它的生态系统。

我们将从一个由关系型数据库和服务器端页面渲染支持 Wiki Web 应用程序开始；然后我们将通过几个步骤改进应用程序，直到它成为具有"实时"footnote:[请注意 在Web技术环境中广泛使用的术语"实时"不应该与特定操作系统的 _硬件_ 或 _软件_ 的实时相混淆。]特征的现代单页面应用。
在整个过程中，你将会学到：

1. 使用模板技术设计一个服务端渲染的 Web 应用，并且使用关系型数据库来持久化数据。
2. 清晰地抽离出每个技术组件，作为一个可以重复使用的事件处理单元被称为 _verticle_。
3. 抽取 Vert.x 的服务，以便于设计在同一 JVM 进程内或集群中的分布式节点之间进行无缝通信的 verticles。
4. 使用异步操作测试代码。
5. 与暴露 HTTP/JSON Web API的第三方服务集成。
6. 对外提供 HTTP/JSON Web API。
7. 使用 HTTPS 来保护和控制访问、Web 浏览器会话验证用户身份以及第三方客户端应用的 JWT 令牌。
8. 借助当下流行的 RxJava 库及它在 Vert.x 集成的反应式编程来重构一些代码。
9. 客户端采用 AngularJS 来开发单页面应用程序。
10. 使用统一的 Vert.x 事件总线集成在 SockJS 上的实时 Web 编程。

NOTE: 本文档和代码示例的源码可以 https://github.com/vert-x3/vertx-guide-for-java-devs 获得。
我们欢迎提交问题报告，反馈以及推送请求！

== 什么是 Vert.x？

[quote]
Eclipse Vert.x 是一个在 JVM 上构建响应式应用程序的工具包。 — Vert.x 官网

Eclipse Vert.x (以下简称 _Vert.x_ ) 是 Eclipse 基金会下的一个开源项目。
Vert.x 于 2012 年由 Tim Fox 发起的。

Vert.x 不是一个框架，而是一个工具包：它的核心库定义编写异步网络应用程序的基础 API，然后你可以选择一些对应用有用的模块(例如，数据库连接，监控，身份验证，日志，服务发现，集群支持等等)。
Vert.x 基于 http://netty.io/[Netty 项目] - 一个为 JVM 设计的高性能异步网络库。
_如果需要的话_，Vert.x 允许你访问 Netty 的内部结构。但是通常来说，使用 Vert.x 提供的高层次 API 会更有利于你编写代码，同时又不会有性能上的损失，相比较 _原生_ Netty来说。

Vert.x does not impose any packaging or build environment.
Since Vert.x core itself is just a regular Jar library it can be embedded inside applications packaged as a set of Jars, a single Jar with all dependencies, or it can even be deployed inside popular component and application containers.

Because Vert.x was designed for asynchronous communications it can deal with more concurrent network connections with less threads than synchronous APIs such as Java servlets or `java.net` socket classes.
Vert.x is useful for a large range of applications: high volume message / event processing, micro-services, API gateways, HTTP APIs for mobile applications, etc.
Vert.x and its ecosystem provide all sorts of technical tools for building end-to-end reactive applications.

While it may sound like Vert.x is only useful for demanding applications, the present guide also states that Vert.x works very well for more traditional web applications.
As we will see, the code will remain relatively easy to comprehend, but if the application needs to face a sudden peak in traffic then the code is already written with the essential ingredient for scaling up: _asynchronous processing of events_.

Finally, it is worth mentioning that Vert.x is _polyglot_ as it supports a wide range of popular JVM languages: Java, Groovy, Scala, Kotlin, JavaScript, Ruby and Ceylon.
The goal when supporting a language in Vert.x is not just to provide access to the APIs, but also to make sure that the language-specific APIs are idiomatic in each target language (e.g., using Scala futures in place of Vert.x futures).
It is well-possible to develop different technical parts of a Vert.x application using different JVM languages.

== Core Vert.x concepts

There are 2 key concepts to learn in Vert.x:

1. what a _verticle_ is, and
2. how the _event bus_ allows verticles to communicate.

=== Threading and programming models

Many networking libraries and frameworks rely on a simple threading strategy: each network client is being assigned a thread upon connection, and this thread deals with the client until it disconnects.
This is the case with Servlet or networking code written with the `java.io` and `java.net` packages.
While this _"synchronous I/O"_ threading model has the advantage of remaining simple to comprehend, it hurts scalability with too many concurrent connections as system threads are not cheap, and under heavy loads an operating system kernel spends significant time _just_ on thread scheduling management.
In such cases we need to move to _"asynchronous I/O"_ for which Vert.x provides a solid foundation.

The unit of deployment in Vert.x is called a _Verticle_.
A verticle processes incoming events over an _event-loop_, where events can be anything like receiving network buffers, timing events, or messages sent by other verticles.
Event-loops are typical in asynchronous programming models:

image::images/event-loop.png[]

Each event shall be processed in a _reasonable_ amount of time to not block the event loop.
This means that _thread blocking_ operations shall not be performed while executed on the event loop, exactly like processing events in a graphical user interface (e.g., freezing a Java / Swing interface by doing a slow network request).
As we will see later in this guide, Vert.x offers mechanisms to deal with blocking operations outside of the event loop.
In any case Vert.x emits warnings in logs when the event loop has been processing an event for _too long_, which is also configurable to match application-specific requirements (e.g., when working on slower IoT ARM boards).

Every event loop is attached to a thread.
By default Vert.x attaches 2 event loops per CPU core thread.
The direct consequence is that a regular verticle always processes events on the same thread, so there is no need to use thread coordination mechanisms to manipulate a verticle state (e.g, Java class fields).

A verticle can be passed some configuration (e.g., credentials, network addresses, etc) and a verticle can be deployed several times:

image::images/verticle-threading-config.png[]

Incoming network data are being received from accepting threads then passed as events to the corresponding verticles.
When a verticle opens a network server and is deployed more than once, then the events are being distributed to the verticle instances in a round-robin fashion which is very useful for maximizing CPU usage with lots of concurrent networked requests.
Finally, verticles have a simple start / stop life-cycle, and verticles can deploy other verticles.

=== Event bus

Verticles form technical units of deployments of code in Vert.x.
The Vert.x _event bus_ is the main tool for different verticles to communicate through asynchronous message passing.
For instance suppose that we have a verticle for dealing with HTTP requests, and a verticle for managing access to the database.
The event bus allows the HTTP verticle to send a request to the database verticle that performs a SQL query, and responds back to the HTTP verticle:

image::images/event-bus.png[]

The event-bus allows passing any kind of data, although JSON is the preferred exchange format since it allows verticles written in different languages to communicate, and more generally JSON is a popular general-purpose semi-structured data marshaling text format.

Message can be sent to _destinations_ which are free-form strings.
The event bus supports the following communication patterns:

1. point-to-point messaging, and
2. request-response messaging and
3. publish / subscribe for broadcasting messages.

The event bus allows verticles to transparently communicate not just within the same JVM process:

* when network clustering is activated, the event bus is _distributed_ so that messages can be sent to verticles running on other application nodes,
* the event-bus can be accessed through a simple TCP protocol for third-party applications to communicate,
* the event-bus can also be exposed over general-purpose messaging bridges (e.g, AMQP, Stomp),
* a SockJS bridge allows web applications to seamlessly communicate over the event bus from JavaScript running in the browser by receiving and publishing messages just like any verticle would do.
